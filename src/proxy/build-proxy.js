const fs = require("fs")
  , pl = require("path");

var proxy = {
  declaration: "",
  detour: "",
  import: "",
  def: "",
  script: "",
  local: ""
};
var result = {
  c: "",
  def: "",
  script: "",
  h: ""
};
var functionNames = function() {
  var file = fs.readFileSync(pl.join(__dirname, "functions.txt"), "utf-8")
    , result = []
    , lines;
  file = file.replace(/\r?\n/g, "\n");
  lines = file.split("\n");
  for (var l of lines) {
    l = l.trim();
    if (!l.length || l[0] == "#")
      continue;
    result.push(l)
  }
  return result
}();

for (var fn of functionNames) {
  proxy.declaration += `static FARPROC pfn_${fn};\n`;
  proxy.detour += `void *${fn}() { return (void *)pfn_${fn}(); }\n`;
  //proxy.detour += `void *${fn}() { return (void *)pfn_${fn}(); }\n`;
  proxy.import += `  pfn_${fn} = GetProcAddress(hModule, "${fn}");\n`;
  proxy.def += `  ${fn} = detour_${fn}\n`;
}

result.c += "// GENERATED BY COMPUTER, DO NOT EDIT.\n";
//result.c += "#include <windows.h>\n\n";
result.c += "typedef unsigned long long INT_PTR, *PINT_PTR;\n";
result.c += "typedef INT_PTR (*FARPROC)();\n";
result.c += "typedef void *HMODULE;\n";
result.c += "extern FARPROC GetProcAddress(HMODULE, const char *);\n\n";
result.c += proxy.declaration + "\n";
result.c += proxy.detour + "\n";
result.c += "void proxy_importFunctions(void *hModule) {\n";
result.c += proxy.import;
result.c += "}\n";

result.def += "EXPORTS\n";
result.def += proxy.def;

result.h += "// GENERATED BY COMPUTER, DO NOT EDIT.\n"
//result.h += "#include <windows.h>\n\n";
result.h += "#ifdef __cplusplus\nextern \"C\" {\n#endif\n"
result.h += "void proxy_importFunctions(void *hModule);\n";
result.h += "#ifdef __cplusplus\n}\n#endif\n"

fs.writeFileSync(pl.join(__dirname, "winhttp-proxy.def"), result.def);
fs.writeFileSync(pl.join(__dirname, "winhttp-proxy.c"), result.c);
fs.writeFileSync(pl.join(__dirname, "winhttp-proxy.h"), result.h);
